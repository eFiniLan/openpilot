From 60fce0657aff353ff4c7658077b1c0486201e41f Mon Sep 17 00:00:00 2001
From: Jacob Pfeifer <jacob@pfeifer.dev>
Date: Fri, 31 Mar 2023 13:51:24 -0400
Subject: [PATCH 2/2] vtsc

---
 common/params.cc                              |   3 +
 .../controls/lib/longitudinal_planner.py      |  25 +-
 .../controls/lib/vision_turn_controller.py    | 221 ++++++++++++++++++
 selfdrive/controls/plannerd.py                |   7 +-
 selfdrive/ui/qt/offroad/settings.cc           |   8 +
 5 files changed, 260 insertions(+), 4 deletions(-)
 create mode 100644 selfdrive/controls/lib/vision_turn_controller.py

diff --git a/common/params.cc b/common/params.cc
index 428830a11..f58681d7d 100644
--- a/common/params.cc
+++ b/common/params.cc
@@ -202,6 +202,9 @@ std::unordered_map<std::string, uint32_t> keys = {
     {"Offroad_TemperatureTooHigh", CLEAR_ON_MANAGER_START},
     {"Offroad_UnofficialHardware", CLEAR_ON_MANAGER_START},
     {"Offroad_UpdateFailed", CLEAR_ON_MANAGER_START},
+// PFEIFER - VTSC {{
+    {"TurnVisionControl", PERSISTENT},
+// }} PFEIFER - VTSC
 };
 
 } // namespace
diff --git a/selfdrive/controls/lib/longitudinal_planner.py b/selfdrive/controls/lib/longitudinal_planner.py
index a2ff42d75..339ef7c2c 100755
--- a/selfdrive/controls/lib/longitudinal_planner.py
+++ b/selfdrive/controls/lib/longitudinal_planner.py
@@ -14,6 +14,9 @@ from selfdrive.controls.lib.longitudinal_mpc_lib.long_mpc import T_IDXS as T_IDX
 from selfdrive.controls.lib.drive_helpers import V_CRUISE_MAX, CONTROL_N
 from selfdrive.controls.lib.vehicle_model import VehicleModel
 from system.swaglog import cloudlog
+# PFEIFER - VTSC {{
+from selfdrive.controls.lib.vision_turn_controller import VisionTurnController
+# }} PFEIFER - VTSC
 
 LON_MPC_STEP = 0.2  # first step is 0.2s
 A_CRUISE_MIN = -1.2
@@ -60,6 +63,10 @@ class LongitudinalPlanner:
     self.solverExecutionTime = 0.0
     self.VM = VehicleModel(CP)
 
+    # PFEIFER - VTSC {{
+    self.vision_turn_controller = VisionTurnController(self.VM)
+    # }} PFEIFER - VTSC
+
   @staticmethod
   def parse_model(model_msg, model_error):
     if (len(model_msg.position.x) == 33 and
@@ -76,7 +83,7 @@ class LongitudinalPlanner:
       j = np.zeros(len(T_IDXS_MPC))
     return x, v, a, j
 
-  def update(self, sm):
+  def update(self, sm, lateral_planner):
     self.mpc.mode = 'blended' if sm['controlsState'].experimentalMode else 'acc'
 
     v_ego = sm['carState'].vEgo
@@ -119,15 +126,29 @@ class LongitudinalPlanner:
 
     if force_slow_decel:
       v_cruise = 0.0
+
+
     # clip limits, cannot init MPC outside of bounds
     accel_limits_turns[0] = min(accel_limits_turns[0], self.a_desired + 0.05)
     accel_limits_turns[1] = max(accel_limits_turns[1], self.a_desired - 0.05)
 
+    # PFEIFER - VTSC {{
+    enabled = not reset_state and self.CP.openpilotLongitudinalControl
+    self.vision_turn_controller.update(enabled, self.v_desired_filter.x, self.a_desired, v_cruise, sm, lateral_planner)
+    v_target = v_cruise
+    if self.vision_turn_controller.active:
+      a_target, v_target = self.vision_turn_controller.plan
+      accel_limits_turns[0] = min(accel_limits_turns[0], a_target)
+    # }} PFEIFER - VTSC
+
     self.mpc.set_weights(prev_accel_constraint)
     self.mpc.set_accel_limits(accel_limits_turns[0], accel_limits_turns[1])
     self.mpc.set_cur_state(self.v_desired_filter.x, self.a_desired)
     x, v, a, j = self.parse_model(sm['modelV2'], self.v_model_error)
-    self.mpc.update(sm['radarState'], v_cruise, x, v, a, j)
+    #self.mpc.update(sm['radarState'], v_cruise, x, v, a, j)
+    # PFEIFER - VTSC {{
+    self.mpc.update(sm['radarState'], v_target, x, v, a, j)
+    # }} PFEIFER - VTSC
 
     self.v_desired_trajectory_full = np.interp(T_IDXS, T_IDXS_MPC, self.mpc.v_solution)
     self.a_desired_trajectory_full = np.interp(T_IDXS, T_IDXS_MPC, self.mpc.a_solution)
diff --git a/selfdrive/controls/lib/vision_turn_controller.py b/selfdrive/controls/lib/vision_turn_controller.py
new file mode 100644
index 000000000..0f5fe7b2e
--- /dev/null
+++ b/selfdrive/controls/lib/vision_turn_controller.py
@@ -0,0 +1,221 @@
+import numpy as np
+import math
+from common.numpy_fast import interp
+from common.params import Params
+from common.realtime import sec_since_boot
+from common.conversions import Conversions as CV
+from selfdrive.controls.lib.drive_helpers import V_CRUISE_MAX
+Polynomial = np.polynomial.polynomial.Polynomial
+
+from selfdrive.controls.lib.drive_helpers import CONTROL_N
+
+
+EVAL_STEP = 5  # mts. Resolution of the curvature evaluation.
+EVAL_START = 20  # mts. Distance ahead where to start evaluating vision curvature.
+EVAL_LENGTH = 150  # mts. Distance ahead where to stop evaluating vision curvature.
+EVAL_RANGE = np.arange(EVAL_START, EVAL_LENGTH, EVAL_STEP)
+
+A_LAT_REG_MAX = 2  # Maximum lateral acceleration
+
+NO_OVERSHOOT_TIME_HORIZON = 4  # s. Time to use for velocity desired based on a_target when not overshooting.
+
+# The minimum amount of lateral acceleration that the controller considers to be an active turn
+TURN_ACTIVE_LIMIT = 1.1 # m/s^2
+
+# Lookup table for the minimum smooth deceleration during the ENTERING state
+# depending on the actual maximum absolute lateral acceleration predicted on the turn ahead.
+SMOOTH_ACCEL_V = [-0.2, -1]  # min decel value allowed on ENTERING state
+SMOOTH_ACCEL_BP = [TURN_ACTIVE_LIMIT, 3]  # absolute value of lat acc ahead
+
+# The maximum this controller will request to decelerate
+MAX_DECEL = -2 # m/s^2
+
+# The maximum amount of deceleration this controller will request while actively in a turn
+MAX_ACTIVE_TURN_DECEL = -1.2 # m/s^2
+
+def eval_lat_acc(v_ego, x_curv):
+  """
+  This function returns a vector with the lateral acceleration based
+  for the provided speed `v_ego` evaluated over curvature vector `x_curv`
+  """
+
+  def lat_acc(curv):
+    a = v_ego**2 * curv
+    return a
+
+  return np.vectorize(lat_acc)(x_curv)
+
+def poly_points_to_curvature(poly, x_points):
+  """
+  This function takes a numpy Polynomial and points on the x axis and returns
+  the curve K at each point.
+
+  ref: https://math24.net/curvature-radius.html
+  curve at a point is defined as the mean curvature of the arc when the
+  displacement along the arc nears 0
+
+           lim       |  delta a  |
+  K = -------------- | --------- |
+       delta s -> 0  |  delta s  |
+
+  radius R is defined as inverse of the curvature K
+  R = 1 / K
+
+  Therefore:
+  K = 1 / R
+
+  R can be obtained when y is a function of x using the following equation:
+
+       ( 1 + y'(x)^2 ) ^ (3/2)
+  R = -------------------------
+             | y''(x) |
+
+  Therefore:
+            | y''(x) |
+  K = -------------------------
+       ( 1 + y'(x)^2 ) ^ (3/2)
+
+  """
+  def point_to_curv(x):
+    dy = poly.deriv()
+    ddy = dy.deriv()
+    k = abs(ddy(x)) / ((1 + dy(x)**2)**(3/2))
+    return k
+
+  return np.vectorize(point_to_curv)(x_points)
+
+class VisionTurnController():
+  def __init__(self, VM):
+    self.params = Params()
+    self.VM = VM
+    self.op_enabled = False
+    self.gas_pressed = False
+    self.last_params_update = 0
+    self.v_cruise_setpoint = 0
+    self.v_ego = 0
+    self.a_ego = 0
+    self.a_target = 0
+    self.v_overshoot = 0
+    self.enabled = self.params.get_bool("TurnVisionControl")
+
+    self.reset()
+
+  @property
+  def active(self):
+    decel_needed = self.max_pred_lat_acc > TURN_ACTIVE_LIMIT or self.current_lat_accel > TURN_ACTIVE_LIMIT
+    return self.op_enabled and not self.gas_pressed and self.enabled and decel_needed
+
+  def reset(self):
+    self.current_lat_accel = 0
+    self.max_v_for_current_curvature = 0
+    self.max_pred_lat_acc = 0
+    self.v_overshoot_distance = 200
+    self.lat_acc_overshoot_ahead = False
+    self.x_plan = []
+    self.y_plan = []
+
+  def update_params(self):
+    time = sec_since_boot()
+    if time > self.last_params_update + 5.0:
+      self.enabled = self.params.get_bool("TurnVisionControl")
+      self.last_params_update = time
+
+  def update_current_state(self, sm):
+    """
+    Uses the current state of the car to calculate the curvature based off the
+    angle of the wheels and store the max acceptable velocity for the curve as
+    well as the current lateral acceleration.
+    """
+    lp = sm['liveParameters']
+    sa = sm['carState'].steeringAngleDeg * CV.DEG_TO_RAD
+    current_curvature = self.VM.calc_curvature(sa, self.v_ego, lp.roll)
+
+    self.current_lat_accel = current_curvature * self.v_ego**2
+
+    if current_curvature > 0:
+      self.max_v_for_current_curvature = math.sqrt(A_LAT_REG_MAX / current_curvature)
+    else:
+      self.max_v_for_current_curvature = V_CRUISE_MAX * CV.KPH_TO_MS
+
+
+  def get_driving_path_poly(self, sm):
+    """
+    Fits the points from the predicted driving path to a numpy polynomial function.
+    """
+    # Calculate curvature polynomial from predicted path
+    if len(self.x_plan) > 3:
+      return Polynomial.fit(self.x_plan, self.y_plan, 4)
+
+    return Polynomial([0, 0, 0, 0])
+
+
+  def update_calculations(self, sm):
+    # Set values related to current curvature
+    self.update_current_state(sm)
+
+    # Fit the model's predicted path to polynomial
+    path_poly = self.get_driving_path_poly(sm)
+
+    # Find curvature values from the predicted driving path
+    predicted_curvatures = poly_points_to_curvature(path_poly, EVAL_RANGE)
+
+    # Get the maximum predicted lateral acceleration from future curvature and current speed
+    max_pred_curvature = np.amax(predicted_curvatures)
+    self.max_pred_lat_acc = self.v_ego**2 * max_pred_curvature
+
+    # Get the largest curvature possible for the current velocity
+    max_curvature_for_vego = A_LAT_REG_MAX / max(self.v_ego, 0.1)**2
+
+    # Find points in the predicted curvature that our current velocity exceeds the max acceptable lateral acceleration
+    lat_acc_overshoot_idxs = np.nonzero(predicted_curvatures >= max_curvature_for_vego)[0]
+
+    # If there is a point that exceeds the max lateral acceleration we calculate
+    # a maximum velocity that fits the acceptable lateral acceleration in the
+    # upcoming curvature. We then calculate the distance to the point at which
+    # the new maximum velocity is needed.
+    self.lat_acc_overshoot_ahead = len(lat_acc_overshoot_idxs) > 0
+    if self.lat_acc_overshoot_ahead:
+      self.v_overshoot = min(math.sqrt(A_LAT_REG_MAX / max_pred_curvature), self.v_cruise_setpoint)
+      self.v_overshoot_distance = max(lat_acc_overshoot_idxs[0] * EVAL_STEP + EVAL_START, EVAL_STEP)
+
+  @property
+  def plan(self):
+    # VTSC not needed or disabled, do not change accel
+    if not self.active:
+      return (self.a_ego, self.v_cruise_setpoint)
+
+    # decel for our current curve as it's greater than predicted curvature
+    if self.current_lat_accel > self.max_pred_lat_acc:
+      a_target = interp(self.max_pred_lat_acc, SMOOTH_ACCEL_BP, SMOOTH_ACCEL_V)
+      v_target = self.v_cruise_setpoint
+
+    else: # decel for future turn
+      a_target = interp(self.max_pred_lat_acc, SMOOTH_ACCEL_BP, SMOOTH_ACCEL_V)
+      v_target = self.v_ego + self.a_target * NO_OVERSHOOT_TIME_HORIZON
+
+    # when overshooting, target the acceleration needed to achieve the overshoot speed at the required distance
+    if self.lat_acc_overshoot_ahead:
+      a_target = min((self.v_overshoot**2 - self.v_ego**2) / (2 * self.v_overshoot_distance), a_target)
+      v_target = self.v_overshoot
+
+    # Limit the requested deceleration by the defined maximum deceleration
+    a_target = max(a_target, MAX_DECEL)
+
+    # While actively turning, limit the requested deceleration by the defined maximum deceleration in a turn
+    if self.current_lat_accel > TURN_ACTIVE_LIMIT:
+      a_target = max(a_target, MAX_ACTIVE_TURN_DECEL)
+
+
+    return (a_target, v_target)
+
+  def update(self, enabled, v_ego, a_ego, v_cruise_setpoint, sm, lateral_planner):
+    self.op_enabled = enabled
+    self.gas_pressed = sm['carState'].gasPressed
+    self.v_ego = v_ego
+    self.a_ego = a_ego
+    self.v_cruise_setpoint = v_cruise_setpoint
+    self.x_plan = lateral_planner.lat_mpc.x_sol[:,0]
+    self.y_plan = lateral_planner.lat_mpc.x_sol[:,1]
+
+    self.update_params()
+    self.update_calculations(sm)
diff --git a/selfdrive/controls/plannerd.py b/selfdrive/controls/plannerd.py
index 42dbd17a7..e78ccb3ec 100755
--- a/selfdrive/controls/plannerd.py
+++ b/selfdrive/controls/plannerd.py
@@ -38,7 +38,10 @@ def plannerd_thread(sm=None, pm=None):
   lateral_planner = LateralPlanner(CP)
 
   if sm is None:
-    sm = messaging.SubMaster(['carControl', 'carState', 'controlsState', 'radarState', 'modelV2', 'liveParameters'],
+    # sm = messaging.SubMaster(['carControl', 'carState', 'controlsState', 'radarState', 'modelV2', 'liveParameters'],
+    # PFEIFER - VTSC {{
+    sm = messaging.SubMaster(['carControl', 'carState', 'controlsState', 'radarState', 'modelV2', 'liveParameters', 'lateralPlan'],
+    # }}
                              poll=['radarState', 'modelV2'], ignore_avg_freq=['radarState'])
 
   if pm is None:
@@ -50,7 +53,7 @@ def plannerd_thread(sm=None, pm=None):
     if sm.updated['modelV2']:
       lateral_planner.update(sm)
       lateral_planner.publish(sm, pm)
-      longitudinal_planner.update(sm)
+      longitudinal_planner.update(sm, lateral_planner)
       longitudinal_planner.publish(sm, pm)
       publish_ui_plan(sm, pm, lateral_planner, longitudinal_planner)
 
diff --git a/selfdrive/ui/qt/offroad/settings.cc b/selfdrive/ui/qt/offroad/settings.cc
index fd14ed15e..1014efb2b 100644
--- a/selfdrive/ui/qt/offroad/settings.cc
+++ b/selfdrive/ui/qt/offroad/settings.cc
@@ -73,6 +73,14 @@ TogglesPanel::TogglesPanel(SettingsWindow *parent) : ListWidget(parent) {
       tr("When enabled, pressing the accelerator pedal will disengage openpilot."),
       "../assets/offroad/icon_disengage_on_accelerator.svg",
     },
+    // PFEIFER - VTSC {{
+    {
+      "TurnVisionControl",
+      tr("V-TSC - Vision Turn Speed Control"),
+tr("Enables V-TSC. When enabled, the car will slow down when it predicts a lateral acceleration greater than 2.0 m/s^2."),
+      "../assets/img_experimental_white.svg",
+    },
+    // }} PFEIFER - VTSC
 #ifdef ENABLE_MAPS
     {
       "NavSettingTime24h",
-- 
2.40.0

