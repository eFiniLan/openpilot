From 6c77f907d4ec7637143854fd7ca75fb0265cdfcc Mon Sep 17 00:00:00 2001
From: Jacob Pfeifer <jacob@pfeifer.dev>
Date: Sat, 10 Jun 2023 15:04:21 -0400
Subject: [PATCH 1/3] button manager

---
 release/files_common                 |   2 +
 selfdrive/controls/button_manager.py | 214 +++++++++++++++++++++++++++
 2 files changed, 216 insertions(+)
 create mode 100644 selfdrive/controls/button_manager.py

diff --git a/release/files_common b/release/files_common
index 54aece853..fe54866c7 100644
--- a/release/files_common
+++ b/release/files_common
@@ -605,3 +605,5 @@ tinygrad_repo/tinygrad/nn/*
 tinygrad_repo/tinygrad/runtime/ops_gpu.py
 tinygrad_repo/tinygrad/shape/*
 tinygrad_repo/tinygrad/*.py
+
+selfdrive/controls/button_manager.py
diff --git a/selfdrive/controls/button_manager.py b/selfdrive/controls/button_manager.py
new file mode 100644
index 000000000..343cf6396
--- /dev/null
+++ b/selfdrive/controls/button_manager.py
@@ -0,0 +1,214 @@
+# PFEIFER - BM
+
+from openpilot.common.params import Params
+from enum import IntEnum
+from time import time
+import json
+
+mem_params = Params("/dev/shm/params")
+
+LONG_PRESS_LENGTH = 0.4 #s
+PRESS_INTERVAL = 0.2 #s
+DEBOUNCE_LENGTH = 0.04 #s
+
+class ButtonState(IntEnum):
+  VOID = 0
+  WAITING_SINGLE_RELEASE = 1
+  LONG_PRESS_WAITING_RELEASE = 2
+  LONG_PRESS = 3
+  SINGLE_PRESS_WAITING_DOUBLE = 4
+  SINGLE_PRESS = 5
+  DOUBLE_PRESS_WAITING_RELEASE = 6
+  DOUBLE_PRESS_WAITING_TRIPLE = 7
+  DOUBLE_PRESS = 8
+  TRIPLE_PRESS_WAITING_RELEASE = 9
+  TRIPLE_PRESS = 10
+
+simple_states = [ButtonState.VOID, ButtonState.LONG_PRESS, ButtonState.SINGLE_PRESS, ButtonState.DOUBLE_PRESS, ButtonState.TRIPLE_PRESS]
+
+class Button:
+  name: str
+  state: ButtonState = ButtonState.VOID
+  transition_id: int = 0
+  last_transition_time: float = time()
+
+  def __init__(self, name: str) -> None:
+    self.name = name
+
+    self.write_state()
+
+    self.state_transition = {
+      ButtonState.VOID: self.update_void_state,
+      ButtonState.WAITING_SINGLE_RELEASE: self.update_waiting_single_release_state,
+      ButtonState.LONG_PRESS_WAITING_RELEASE: self.update_long_press_waiting_release_state,
+      ButtonState.LONG_PRESS: self.update_long_press_state,
+      ButtonState.SINGLE_PRESS_WAITING_DOUBLE: self.update_single_press_waiting_double_state,
+      ButtonState.SINGLE_PRESS: self.update_single_press_state,
+      ButtonState.DOUBLE_PRESS_WAITING_RELEASE: self.update_double_press_waiting_release_state,
+      ButtonState.DOUBLE_PRESS_WAITING_TRIPLE: self.update_double_press_waiting_triple_state,
+      ButtonState.DOUBLE_PRESS: self.update_double_press_state,
+      ButtonState.TRIPLE_PRESS_WAITING_RELEASE: self.update_triple_press_waiting_release_state,
+      ButtonState.TRIPLE_PRESS: self.update_triple_press_state,
+    }
+
+  def update_transition_time(self) -> None:
+    self.last_transition_time = time()
+
+  def press_interval_elapsed(self) -> bool:
+    return (time() - self.last_transition_time) > PRESS_INTERVAL
+
+  def long_press_length_elapsed(self) -> bool:
+    return (time() - self.last_transition_time) > LONG_PRESS_LENGTH
+
+  def debounce_length_elapsed(self) -> bool:
+    return (time() - self.last_transition_time) > DEBOUNCE_LENGTH
+
+
+  @property
+  def simple_state(self) -> ButtonState:
+    """
+    For most transitional states this returns void. For transitional states that
+    only have a single possible final state this returns the final state.
+    Possible output states are the following: VOID, LONG_PRESS, SINGLE_PRESS,
+    DOUBLE_PRESS, TRIPLE_PRESS
+    """
+    if self.state in simple_states:
+      return self.state
+
+    if self.state == ButtonState.TRIPLE_PRESS_WAITING_RELEASE:
+      return ButtonState.TRIPLE_PRESS
+
+    if self.state == ButtonState.LONG_PRESS_WAITING_RELEASE:
+      return ButtonState.LONG_PRESS
+
+    return ButtonState.VOID
+
+  @property
+  def simple_transition_id(self) -> int:
+    """
+    If a state only has a single possible final state this returns the next
+    transition id, otherwise it responds with the current transition id. Useful
+    For determining changes in simple state.
+    """
+    if self.state == ButtonState.TRIPLE_PRESS_WAITING_RELEASE:
+      return self.transition_id + 1
+
+    if self.state == ButtonState.LONG_PRESS_WAITING_RELEASE:
+      return self.transition_id + 1
+
+    return self.transition_id
+
+  @property
+  def dict(self):
+    return {
+      "state": int(self.state),
+      "transition_id": self.transition_id,
+      "last_transition_time": self.last_transition_time
+    }
+
+  def write_state(self) -> None:
+    mem_params.put(self.name, json.dumps(self.dict))
+
+  def load_state(self) -> None:
+    try:
+      state_dict = json.loads(mem_params.get(self.name))
+      self.state = ButtonState(state_dict["state"])
+      self.transition_id = state_dict["transition_id"]
+      self.last_transition_time = state_dict["last_transition_time"]
+    except:
+      self.state = ButtonState.VOID
+      self.transition_id = 0
+      self.last_transition_time = time()
+
+  def update(self, button_pressed: bool, load_state = True, write_state = True) -> ButtonState:
+    if load_state:
+      self.load_state()
+
+    if not self.debounce_length_elapsed():
+      return self.state
+
+    state = self.state_transition[self.state](button_pressed)
+
+    if self.state != state:
+      self.state = state
+      self.transition_id += 1
+      self.update_transition_time()
+      if write_state:
+        self.write_state()
+
+    return self.state
+
+  # ---------------- STATE TRANSITIONS ----------------------------
+  def update_void_state(self, button_pressed: bool) -> ButtonState:
+    if button_pressed:
+      return ButtonState.WAITING_SINGLE_RELEASE
+
+    return self.state
+
+  def update_waiting_single_release_state(self, button_pressed: bool) -> ButtonState:
+    if button_pressed and self.long_press_length_elapsed():
+      return ButtonState.LONG_PRESS_WAITING_RELEASE
+
+    if not button_pressed:
+      return ButtonState.SINGLE_PRESS_WAITING_DOUBLE
+
+    return self.state
+
+  def update_long_press_waiting_release_state(self, button_pressed: bool) -> ButtonState:
+    if not button_pressed:
+      return ButtonState.LONG_PRESS
+
+    return self.state
+
+  def update_long_press_state(self, button_pressed: bool) -> ButtonState:
+    if button_pressed:
+      return ButtonState.WAITING_SINGLE_RELEASE
+
+    return self.state
+
+  def update_single_press_waiting_double_state(self, button_pressed: bool) -> ButtonState:
+    if not button_pressed and self.press_interval_elapsed():
+      return ButtonState.SINGLE_PRESS
+
+    if button_pressed:
+      return ButtonState.DOUBLE_PRESS_WAITING_RELEASE
+
+    return self.state
+
+  def update_single_press_state(self, button_pressed: bool) -> ButtonState:
+    if button_pressed:
+      return ButtonState.WAITING_SINGLE_RELEASE
+
+    return self.state
+
+  def update_double_press_waiting_release_state(self, button_pressed: bool) -> ButtonState:
+      if not button_pressed:
+        return ButtonState.DOUBLE_PRESS_WAITING_TRIPLE
+
+      return self.state
+
+  def update_double_press_waiting_triple_state(self, button_pressed: bool) -> ButtonState:
+      if not button_pressed and self.press_interval_elapsed():
+        return ButtonState.DOUBLE_PRESS
+      if button_pressed:
+        return ButtonState.TRIPLE_PRESS_WAITING_RELEASE
+
+      return self.state
+
+  def update_double_press_state(self, button_pressed: bool) -> ButtonState:
+      if button_pressed:
+        return ButtonState.WAITING_SINGLE_RELEASE
+
+      return self.state
+
+  def update_triple_press_waiting_release_state(self, button_pressed: bool) -> ButtonState:
+    if not button_pressed:
+        return ButtonState.TRIPLE_PRESS
+
+    return self.state
+
+  def update_triple_press_state(self, button_pressed: bool) -> ButtonState:
+    if button_pressed:
+      return ButtonState.WAITING_SINGLE_RELEASE
+
+    return self.state
-- 
2.39.2


From 2e845f5bc39280be2ad3989c28f0ccacfb975bcc Mon Sep 17 00:00:00 2001
From: Jacob Pfeifer <jacob@pfeifer.dev>
Date: Sat, 24 Jun 2023 17:59:36 -0400
Subject: [PATCH 2/3] gap adjust button

---
 common/params.cc                        |  4 ++++
 release/files_common                    |  1 +
 selfdrive/car/gm/carstate.py            |  9 +++++++++
 selfdrive/car/hyundai/interface.py      |  9 +++++++++
 selfdrive/car/toyota/carstate.py        | 12 ++++++++++++
 selfdrive/controls/gap_adjust_button.py | 13 +++++++++++++
 6 files changed, 48 insertions(+)
 create mode 100644 selfdrive/controls/gap_adjust_button.py

diff --git a/common/params.cc b/common/params.cc
index 63baa3031..89b03846f 100644
--- a/common/params.cc
+++ b/common/params.cc
@@ -207,6 +207,10 @@ std::unordered_map<std::string, uint32_t> keys = {
     {"Version", PERSISTENT},
     {"VisionRadarToggle", PERSISTENT},
     {"WheeledBody", PERSISTENT},
+
+    // PFEIFER - GAB {{
+    {"GapAdjustButton", PERSISTENT},
+    // }} PFEIFER - GAB
 };
 
 } // namespace
diff --git a/release/files_common b/release/files_common
index fe54866c7..29313a42e 100644
--- a/release/files_common
+++ b/release/files_common
@@ -607,3 +607,4 @@ tinygrad_repo/tinygrad/shape/*
 tinygrad_repo/tinygrad/*.py
 
 selfdrive/controls/button_manager.py
+selfdrive/controls/gap_adjust_button.py
diff --git a/selfdrive/car/gm/carstate.py b/selfdrive/car/gm/carstate.py
index 8585e9f20..ae9c591e0 100644
--- a/selfdrive/car/gm/carstate.py
+++ b/selfdrive/car/gm/carstate.py
@@ -7,6 +7,10 @@ from opendbc.can.parser import CANParser
 from openpilot.selfdrive.car.interfaces import CarStateBase
 from openpilot.selfdrive.car.gm.values import DBC, AccState, CanBus, STEER_THRESHOLD
 
+# PFEIFER - GAB {{
+from openpilot.selfdrive.controls.gap_adjust_button import gap_adjust_button
+# }} PFEIFER - GAB
+
 TransmissionType = car.CarParams.TransmissionType
 NetworkLocation = car.CarParams.NetworkLocation
 STANDSTILL_THRESHOLD = 10 * 0.0311 * CV.KPH_TO_MS
@@ -29,6 +33,11 @@ class CarState(CarStateBase):
   def update(self, pt_cp, cam_cp, loopback_cp):
     ret = car.CarState.new_message()
 
+    # PFEIFER - GAB {{
+    distance_button_pressed = pt_cp.vl["ASCMSteeringButton"]["DistanceButton"] != 0
+    gap_adjust_button.update(distance_button_pressed)
+    # }} PFEIFER - GAB
+
     self.prev_cruise_buttons = self.cruise_buttons
     self.cruise_buttons = pt_cp.vl["ASCMSteeringButton"]["ACCButtons"]
     self.buttons_counter = pt_cp.vl["ASCMSteeringButton"]["RollingCounter"]
diff --git a/selfdrive/car/hyundai/interface.py b/selfdrive/car/hyundai/interface.py
index ff278d54e..efe259316 100644
--- a/selfdrive/car/hyundai/interface.py
+++ b/selfdrive/car/hyundai/interface.py
@@ -11,6 +11,10 @@ from openpilot.selfdrive.car import create_button_events, get_safety_config
 from openpilot.selfdrive.car.interfaces import CarInterfaceBase
 from openpilot.selfdrive.car.disable_ecu import disable_ecu
 
+# PFEIFER - GAB {{
+from openpilot.selfdrive.controls.gap_adjust_button import gap_adjust_button
+# }} PFEIFER - GAB
+
 Ecu = car.CarParams.Ecu
 ButtonType = car.CarState.ButtonEvent.Type
 EventName = car.CarEvent.EventName
@@ -328,6 +332,11 @@ class CarInterface(CarInterfaceBase):
     if self.CS.CP.openpilotLongitudinalControl:
       ret.buttonEvents = create_button_events(self.CS.cruise_buttons[-1], self.CS.prev_cruise_buttons, BUTTONS_DICT)
 
+    # PFEIFER - GAB {{
+    gap_button_pressed = (self.CS.cruise_buttons[-1] == Buttons.GAP_DIST)
+    gap_adjust_button.update(gap_button_pressed)
+    # }} PFEIFER - GAB
+
     # On some newer model years, the CANCEL button acts as a pause/resume button based on the PCM state
     # To avoid re-engaging when openpilot cancels, check user engagement intention via buttons
     # Main button also can trigger an engagement on these cars
diff --git a/selfdrive/car/toyota/carstate.py b/selfdrive/car/toyota/carstate.py
index 076668fff..ef7d498a0 100644
--- a/selfdrive/car/toyota/carstate.py
+++ b/selfdrive/car/toyota/carstate.py
@@ -11,6 +11,10 @@ from openpilot.selfdrive.car.interfaces import CarStateBase
 from openpilot.selfdrive.car.toyota.values import ToyotaFlags, CAR, DBC, STEER_THRESHOLD, NO_STOP_TIMER_CAR, \
                                                   TSS2_CAR, RADAR_ACC_CAR, EPS_SCALE, UNSUPPORTED_DSU_CAR
 
+# PFEIFER - GAB {{
+from openpilot.selfdrive.controls.gap_adjust_button import gap_adjust_button
+# }} PFEIFER - GAB
+
 SteerControlType = car.CarParams.SteerControlType
 
 # These steering fault definitions seem to be common across LKA (torque) and LTA (angle):
@@ -163,6 +167,14 @@ class CarState(CarStateBase):
     if self.CP.carFingerprint != CAR.PRIUS_V:
       self.lkas_hud = copy.copy(cp_cam.vl["LKAS_HUD"])
 
+    # PFEIFER - GAB {{
+    distance_button_pressed = False
+    if self.CP.carFingerprint in TSS2_CAR:
+      if 'DISTANCE' in cp_acc.vl["ACC_CONTROL"]:
+        distance_button_pressed = cp_acc.vl["ACC_CONTROL"]["DISTANCE"] == 1
+        gap_adjust_button.update(distance_button_pressed)
+    # }} PFEIFER - GAB
+
     return ret
 
   @staticmethod
diff --git a/selfdrive/controls/gap_adjust_button.py b/selfdrive/controls/gap_adjust_button.py
new file mode 100644
index 000000000..f34ff3a7f
--- /dev/null
+++ b/selfdrive/controls/gap_adjust_button.py
@@ -0,0 +1,13 @@
+# PFEIFER - GAB
+
+# Acknowledgements:
+# HKG button state was pulled from sunnypilot. https://github.com/sunnyhaibin/sunnypilot
+# GM button state was pulled from OPGM. https://github.com/opgm/openpilot
+# Toyota button state was pulled from Frogpilot who pulled it from krkeegan. https://github.com/FrogAi/FrogPilot | https://github.com/krkeegan/openpilot
+
+from openpilot.selfdrive.controls.button_manager import Button, ButtonState
+
+# export button state so only one import is necessary
+GapButtonState = ButtonState
+
+gap_adjust_button = Button("GapAdjustButton")
-- 
2.39.2


From 51a6ece0ae0dd8b5fe20531ad3a2b7cee3d24e34 Mon Sep 17 00:00:00 2001
From: Jacob Pfeifer <jacob@pfeifer.dev>
Date: Sat, 10 Jun 2023 15:35:40 -0400
Subject: [PATCH 3/3] gap adjust control

---
 release/files_common                     |  1 +
 selfdrive/car/gm/gmcan.py                | 12 +++-
 selfdrive/car/hyundai/hyundaican.py      | 12 +++-
 selfdrive/car/toyota/carstate.py         | 14 +++++
 selfdrive/car/toyota/toyotacan.py        | 14 ++++-
 selfdrive/controls/controlsd.py          |  8 +++
 selfdrive/controls/gap_adjust_control.py | 74 ++++++++++++++++++++++++
 7 files changed, 132 insertions(+), 3 deletions(-)
 create mode 100644 selfdrive/controls/gap_adjust_control.py

diff --git a/release/files_common b/release/files_common
index 29313a42e..83e6e69d6 100644
--- a/release/files_common
+++ b/release/files_common
@@ -608,3 +608,4 @@ tinygrad_repo/tinygrad/*.py
 
 selfdrive/controls/button_manager.py
 selfdrive/controls/gap_adjust_button.py
+selfdrive/controls/gap_adjust_control.py
diff --git a/selfdrive/car/gm/gmcan.py b/selfdrive/car/gm/gmcan.py
index bd1e29ce3..3653de312 100644
--- a/selfdrive/car/gm/gmcan.py
+++ b/selfdrive/car/gm/gmcan.py
@@ -1,5 +1,8 @@
 from openpilot.selfdrive.car import make_can_msg
 from openpilot.selfdrive.car.gm.values import CAR
+# PFEIFER - GAC {{
+from openpilot.selfdrive.controls.gap_adjust_control import gap_adjust
+# }} PFEIFER - GAC
 
 
 def create_buttons(packer, bus, idx, button):
@@ -105,11 +108,18 @@ def create_friction_brake_command(packer, bus, apply_brake, idx, enabled, near_s
 def create_acc_dashboard_command(packer, bus, enabled, target_speed_kph, lead_car_in_sight, fcw):
   target_speed = min(target_speed_kph, 255)
 
+  # PFEIFER - GAC {{
+  gap_set = gap_adjust.state + 1
+  # }} PFEIFER - GAC
+
   values = {
     "ACCAlwaysOne": 1,
     "ACCResumeButton": 0,
     "ACCSpeedSetpoint": target_speed,
-    "ACCGapLevel": 3 * enabled,  # 3 "far", 0 "inactive"
+    # "ACCGapLevel": 3 * enabled,  # 3 "far", 0 "inactive"
+    # PFEIFER - GAC {{
+    "ACCGapLevel": gap_set * enabled,  # 3 "far", 0 "inactive"
+    # }} PFEIFER - GAC
     "ACCCmdActive": enabled,
     "ACCAlwaysOne2": 1,
     "ACCLeadCar": lead_car_in_sight,
diff --git a/selfdrive/car/hyundai/hyundaican.py b/selfdrive/car/hyundai/hyundaican.py
index 008397402..11664b12d 100644
--- a/selfdrive/car/hyundai/hyundaican.py
+++ b/selfdrive/car/hyundai/hyundaican.py
@@ -1,5 +1,8 @@
 import crcmod
 from openpilot.selfdrive.car.hyundai.values import CAR, CHECKSUM, CAMERA_SCC_CAR
+# PFEIFER - GAC {{
+from openpilot.selfdrive.controls.gap_adjust_control import gap_adjust
+# }} PFEIFER - GAC
 
 hyundai_checksum = crcmod.mkCrcFun(0x11D, initCrc=0xFD, rev=False, xorOut=0xdf)
 
@@ -128,9 +131,16 @@ def create_lfahda_mfc(packer, enabled, hda_set_speed=0):
 def create_acc_commands(packer, enabled, accel, upper_jerk, idx, lead_visible, set_speed, stopping, long_override, use_fca):
   commands = []
 
+  # PFEIFER - GAC {{
+  gap_set = gap_adjust.state + 1
+  # }} PFEIFER - GAC
+
   scc11_values = {
     "MainMode_ACC": 1,
-    "TauGapSet": 4,
+    # "TauGapSet": 4,
+    # PFEIFER - GAC {{
+    "TauGapSet": gap_set,
+    # }} PFEIFER - GAC
     "VSetDis": set_speed if enabled else 0,
     "AliveCounterACC": idx % 0x10,
     "ObjValid": 1, # close lead makes controls tighter
diff --git a/selfdrive/car/toyota/carstate.py b/selfdrive/car/toyota/carstate.py
index ef7d498a0..f10bb10e7 100644
--- a/selfdrive/car/toyota/carstate.py
+++ b/selfdrive/car/toyota/carstate.py
@@ -15,6 +15,10 @@ from openpilot.selfdrive.car.toyota.values import ToyotaFlags, CAR, DBC, STEER_T
 from openpilot.selfdrive.controls.gap_adjust_button import gap_adjust_button
 # }} PFEIFER - GAB
 
+# PFEIFER - GAC {{
+from openpilot.selfdrive.controls.gap_adjust_control import gap_adjust
+# }} PFEIFER - GAC
+
 SteerControlType = car.CarParams.SteerControlType
 
 # These steering fault definitions seem to be common across LKA (torque) and LTA (angle):
@@ -175,6 +179,13 @@ class CarState(CarStateBase):
         gap_adjust_button.update(distance_button_pressed)
     # }} PFEIFER - GAB
 
+    # PFEIFER - GAC {{
+    if self.CP.carFingerprint in TSS2_CAR:
+      if "DISTANCE_LINES" in cp.vl["PCM_CRUISE_SM"]:
+        personality = max(cp.vl["PCM_CRUISE_SM"]["DISTANCE_LINES"] - 1, 0)
+        gap_adjust.update_from_car_state(personality)
+    # }} PFEIFER - GAC
+
     return ret
 
   @staticmethod
@@ -243,6 +254,9 @@ class CarState(CarStateBase):
         ("PRE_COLLISION", 33),
         ("ACC_CONTROL", 33),
         ("PCS_HUD", 1),
+        # PFEIFER - GAC {{
+        ("PCM_CRUISE_SM", 0),
+        # }} PFEIFER - GAC
       ]
 
     return CANParser(DBC[CP.carFingerprint]["pt"], messages, 2)
diff --git a/selfdrive/car/toyota/toyotacan.py b/selfdrive/car/toyota/toyotacan.py
index ed0237c1b..fc56977ec 100644
--- a/selfdrive/car/toyota/toyotacan.py
+++ b/selfdrive/car/toyota/toyotacan.py
@@ -1,3 +1,7 @@
+# PFEIFER - GAC {{
+from openpilot.selfdrive.controls.gap_adjust_control import gap_adjust
+# }} PFEIFER - GAC
+
 def create_steer_command(packer, steer, steer_req):
   """Creates a CAN message for the Toyota Steer Command."""
 
@@ -28,11 +32,19 @@ def create_lta_steer_command(packer, steer_angle, steer_req, frame, setme_x64):
 
 
 def create_accel_command(packer, accel, pcm_cancel, standstill_req, lead, acc_type, fcw_alert):
+
+  # PFEIFER - GAC {{
+  distance_transition = int(gap_adjust.transition_car_state())
+  # }} PFEIFER - GAC
+
   # TODO: find the exact canceling bit that does not create a chime
   values = {
     "ACCEL_CMD": accel,
     "ACC_TYPE": acc_type,
-    "DISTANCE": 0,
+    # "DISTANCE": 0,
+    # PFEIFER - GAC {{
+    "DISTANCE": distance_transition,
+    # }} PFEIFER - GAC
     "MINI_CAR": lead,
     "PERMIT_BRAKING": 1,
     "RELEASE_STANDSTILL": not standstill_req,
diff --git a/selfdrive/controls/controlsd.py b/selfdrive/controls/controlsd.py
index 809403073..1dc7c20ad 100755
--- a/selfdrive/controls/controlsd.py
+++ b/selfdrive/controls/controlsd.py
@@ -29,6 +29,10 @@ from openpilot.selfdrive.controls.lib.alertmanager import AlertManager, set_offr
 from openpilot.selfdrive.controls.lib.vehicle_model import VehicleModel
 from openpilot.system.hardware import HARDWARE
 
+# PFEIFER - GAC {{
+from openpilot.selfdrive.controls.gap_adjust_control import gap_adjust
+# }} PFEIFER - GAC
+
 SOFT_DISABLE_TIME = 3  # seconds
 LDW_MIN_SPEED = 31 * CV.MPH_TO_MS
 LANE_DEPARTURE_THRESHOLD = 0.1
@@ -857,6 +861,10 @@ class Controls:
     self.update_events(CS)
     cloudlog.timestamp("Events updated")
 
+    # PFEIFER - GAC {{
+    gap_adjust.update()
+    # }} PFEIFER - GAC
+
     if not self.read_only and self.initialized:
       # Update control state
       self.state_transition(CS)
diff --git a/selfdrive/controls/gap_adjust_control.py b/selfdrive/controls/gap_adjust_control.py
new file mode 100644
index 000000000..466e2f432
--- /dev/null
+++ b/selfdrive/controls/gap_adjust_control.py
@@ -0,0 +1,74 @@
+# PFEIFER - GAC
+# Acknowledgements:
+# HKG dashboard display pulled from sunnypilot. https://github.com/sunnyhaibin/sunnypilot
+# GM dashboard display pulled from OPGM. https://github.com/opgm/openpilot
+
+from openpilot.common.params import Params, put_nonblocking
+from enum import IntEnum
+from openpilot.selfdrive.controls.gap_adjust_button import gap_adjust_button, GapButtonState
+
+params = Params()
+
+class GapAdjustState(IntEnum):
+  AGGRESSIVE = 0
+  STANDARD = 1
+  RELAXED = 2
+
+class GapAdjust:
+  state: GapAdjustState = GapAdjustState.STANDARD
+  button_transition_id = 0
+  disable_default_update = False
+
+  def __init__(self) -> None:
+    self.load_state()
+
+  def load_state(self) -> None:
+    try:
+      self.state = GapAdjustState(int(params.get('LongitudinalPersonality')))
+    except:
+      self.state = GapAdjustState.STANDARD
+
+  def write_state(self) -> None:
+    put_nonblocking('LongitudinalPersonality', str(int(self.state)))
+
+  def update(self, load_state=True, write_state=True, load_button_state=True) -> None:
+    if self.disable_default_update:
+      return
+
+    if load_button_state:
+      gap_adjust_button.load_state()
+
+    transition_id = gap_adjust_button.simple_transition_id;
+
+    if self.button_transition_id != transition_id:
+      self.button_transition_id = transition_id
+      if gap_adjust_button.simple_state == GapButtonState.SINGLE_PRESS:
+        if load_state:
+          self.load_state()
+
+        self.state = GapAdjustState((int(self.state) + 1) % 3)
+
+        if write_state:
+          self.write_state()
+
+  def transition_car_state(self, load_button_state=True):
+    transition_id = gap_adjust_button.simple_transition_id;
+
+    if self.button_transition_id != transition_id:
+      self.button_transition_id = transition_id
+      if gap_adjust_button.simple_state == GapButtonState.SINGLE_PRESS:
+        return True
+
+    return False
+
+
+  def update_from_car_state(self, state: GapAdjustState, write_state=True) -> None:
+    self.disable_default_update = True
+
+    old_state = self.state
+    self.state = GapAdjustState(state % 3)
+
+    if write_state and old_state != self.state:
+      self.write_state()
+
+gap_adjust = GapAdjust()
-- 
2.39.2

