From ef4d94814f053605a5719ec2453c0a5658d91546 Mon Sep 17 00:00:00 2001
From: Jacob Pfeifer <jacob@pfeifer.dev>
Date: Sat, 10 Jun 2023 15:04:21 -0400
Subject: [PATCH 1/3] button manager

---
 selfdrive/controls/button_manager.py | 214 +++++++++++++++++++++++++++
 1 file changed, 214 insertions(+)
 create mode 100644 selfdrive/controls/button_manager.py

diff --git a/selfdrive/controls/button_manager.py b/selfdrive/controls/button_manager.py
new file mode 100644
index 000000000..dee8f649a
--- /dev/null
+++ b/selfdrive/controls/button_manager.py
@@ -0,0 +1,214 @@
+# PFEIFER - BM
+
+from common.params import Params
+from enum import IntEnum
+from time import time
+import json
+
+mem_params = Params("/dev/shm/params")
+
+LONG_PRESS_LENGTH = 0.4 #s
+PRESS_INTERVAL = 0.2 #s
+DEBOUNCE_LENGTH = 0.03 #s
+
+class ButtonState(IntEnum):
+  VOID = 0
+  WAITING_SINGLE_RELEASE = 1
+  LONG_PRESS_WAITING_RELEASE = 2
+  LONG_PRESS = 3
+  SINGLE_PRESS_WAITING_DOUBLE = 4
+  SINGLE_PRESS = 5
+  DOUBLE_PRESS_WAITING_RELEASE = 6
+  DOUBLE_PRESS_WAITING_TRIPLE = 7
+  DOUBLE_PRESS = 8
+  TRIPLE_PRESS_WAITING_RELEASE = 9
+  TRIPLE_PRESS = 10
+
+simple_states = [ButtonState.VOID, ButtonState.LONG_PRESS, ButtonState.SINGLE_PRESS, ButtonState.DOUBLE_PRESS, ButtonState.TRIPLE_PRESS]
+
+class Button:
+  name: str
+  state: ButtonState = ButtonState.VOID
+  transition_id: int = 0
+  last_transition_time: float = time()
+
+  def __init__(self, name: str) -> None:
+    self.name = name
+
+    self.write_state()
+
+    self.state_transition = {
+      ButtonState.VOID: self.update_void_state,
+      ButtonState.WAITING_SINGLE_RELEASE: self.update_waiting_single_release_state,
+      ButtonState.LONG_PRESS_WAITING_RELEASE: self.update_long_press_waiting_release_state,
+      ButtonState.LONG_PRESS: self.update_long_press_state,
+      ButtonState.SINGLE_PRESS_WAITING_DOUBLE: self.update_single_press_waiting_double_state,
+      ButtonState.SINGLE_PRESS: self.update_single_press_state,
+      ButtonState.DOUBLE_PRESS_WAITING_RELEASE: self.update_double_press_waiting_release_state,
+      ButtonState.DOUBLE_PRESS_WAITING_TRIPLE: self.update_double_press_waiting_triple_state,
+      ButtonState.DOUBLE_PRESS: self.update_double_press_state,
+      ButtonState.TRIPLE_PRESS_WAITING_RELEASE: self.update_triple_press_waiting_release_state,
+      ButtonState.TRIPLE_PRESS: self.update_triple_press_state,
+    }
+
+  def update_transition_time(self) -> None:
+    self.last_transition_time = time()
+
+  def press_interval_elapsed(self) -> bool:
+    return (time() - self.last_transition_time) > PRESS_INTERVAL
+
+  def long_press_length_elapsed(self) -> bool:
+    return (time() - self.last_transition_time) > LONG_PRESS_LENGTH
+
+  def debounce_length_elapsed(self) -> bool:
+    return (time() - self.last_transition_time) > DEBOUNCE_LENGTH
+
+
+  @property
+  def simple_state(self) -> ButtonState:
+    """
+    For most transitional states this returns void. For transitional states that
+    only have a single possible final state this returns the final state.
+    Possible output states are the following: VOID, LONG_PRESS, SINGLE_PRESS,
+    DOUBLE_PRESS, TRIPLE_PRESS
+    """
+    if self.state in simple_states:
+      return self.state
+
+    if self.state == ButtonState.TRIPLE_PRESS_WAITING_RELEASE:
+      return ButtonState.TRIPLE_PRESS
+
+    if self.state == ButtonState.LONG_PRESS_WAITING_RELEASE:
+      return ButtonState.LONG_PRESS
+
+    return ButtonState.VOID
+
+  @property
+  def simple_transition_id(self) -> int:
+    """
+    If a state only has a single possible final state this returns the next
+    transition id, otherwise it responds with the current transition id. Useful
+    For determining changes in simple state.
+    """
+    if self.state == ButtonState.TRIPLE_PRESS_WAITING_RELEASE:
+      return self.transition_id + 1
+
+    if self.state == ButtonState.LONG_PRESS_WAITING_RELEASE:
+      return self.transition_id + 1
+
+    return self.transition_id
+
+  @property
+  def dict(self):
+    return {
+      "state": int(self.state),
+      "transition_id": self.transition_id,
+      "last_transition_time": self.last_transition_time
+    }
+
+  def write_state(self) -> None:
+    mem_params.put(self.name, json.dumps(self.dict))
+
+  def load_state(self) -> None:
+    try:
+      state_dict = json.loads(mem_params.get(self.name))
+      self.state = ButtonState(state_dict["state"])
+      self.transition_id = state_dict["transition_id"]
+      self.last_transition_time = state_dict["last_transition_time"]
+    except:
+      self.state = ButtonState.VOID
+      self.transition_id = 0
+      self.last_transition_time = time()
+
+  def update(self, button_pressed: bool, load_state = True, write_state = True) -> ButtonState:
+    if load_state:
+      self.load_state()
+
+    if not self.debounce_length_elapsed():
+      return self.state
+
+    state = self.state_transition[self.state](button_pressed)
+
+    if self.state != state:
+      self.state = state
+      self.transition_id += 1
+      self.update_transition_time()
+      if write_state:
+        self.write_state()
+
+    return self.state
+
+  # ---------------- STATE TRANSITIONS ----------------------------
+  def update_void_state(self, button_pressed: bool) -> ButtonState:
+    if button_pressed:
+      return ButtonState.WAITING_SINGLE_RELEASE
+
+    return self.state
+
+  def update_waiting_single_release_state(self, button_pressed: bool) -> ButtonState:
+    if button_pressed and self.long_press_length_elapsed():
+      return ButtonState.LONG_PRESS_WAITING_RELEASE
+
+    if not button_pressed:
+      return ButtonState.SINGLE_PRESS_WAITING_DOUBLE
+
+    return self.state
+
+  def update_long_press_waiting_release_state(self, button_pressed: bool) -> ButtonState:
+    if not button_pressed:
+      return ButtonState.LONG_PRESS
+
+    return self.state
+
+  def update_long_press_state(self, button_pressed: bool) -> ButtonState:
+    if button_pressed:
+      return ButtonState.WAITING_SINGLE_RELEASE
+
+    return self.state
+
+  def update_single_press_waiting_double_state(self, button_pressed: bool) -> ButtonState:
+    if not button_pressed and self.press_interval_elapsed():
+      return ButtonState.SINGLE_PRESS
+
+    if button_pressed:
+      return ButtonState.DOUBLE_PRESS_WAITING_RELEASE
+
+    return self.state
+
+  def update_single_press_state(self, button_pressed: bool) -> ButtonState:
+    if button_pressed:
+      return ButtonState.WAITING_SINGLE_RELEASE
+
+    return self.state
+
+  def update_double_press_waiting_release_state(self, button_pressed: bool) -> ButtonState:
+      if not button_pressed:
+        return ButtonState.DOUBLE_PRESS_WAITING_TRIPLE
+
+      return self.state
+
+  def update_double_press_waiting_triple_state(self, button_pressed: bool) -> ButtonState:
+      if not button_pressed and self.press_interval_elapsed():
+        return ButtonState.DOUBLE_PRESS
+      if button_pressed:
+        return ButtonState.TRIPLE_PRESS_WAITING_RELEASE
+
+      return self.state
+
+  def update_double_press_state(self, button_pressed: bool) -> ButtonState:
+      if button_pressed:
+        return ButtonState.WAITING_SINGLE_RELEASE
+
+      return self.state
+
+  def update_triple_press_waiting_release_state(self, button_pressed: bool) -> ButtonState:
+    if not button_pressed:
+        return ButtonState.TRIPLE_PRESS
+
+    return self.state
+
+  def update_triple_press_state(self, button_pressed: bool) -> ButtonState:
+    if button_pressed:
+      return ButtonState.WAITING_SINGLE_RELEASE
+
+    return self.state
-- 
2.41.0


From b2ead8168b43fc04ce62962a826017ce6c5fbae9 Mon Sep 17 00:00:00 2001
From: Jacob Pfeifer <jacob@pfeifer.dev>
Date: Sat, 24 Jun 2023 17:59:36 -0400
Subject: [PATCH 2/3] gap adjust button

---
 common/params.cc                        | 4 ++++
 selfdrive/car/hyundai/interface.py      | 9 +++++++++
 selfdrive/controls/gap_adjust_button.py | 8 ++++++++
 3 files changed, 21 insertions(+)
 create mode 100644 selfdrive/controls/gap_adjust_button.py

diff --git a/common/params.cc b/common/params.cc
index 509d419d6..2d74023d1 100644
--- a/common/params.cc
+++ b/common/params.cc
@@ -205,6 +205,10 @@ std::unordered_map<std::string, uint32_t> keys = {
     {"UpdaterTargetBranch", CLEAR_ON_MANAGER_START},
     {"Version", PERSISTENT},
     {"VisionRadarToggle", PERSISTENT},
+
+    // PFEIFER - GAB {{
+    {"GapAdjustButton", PERSISTENT},
+    // }} PFEIFER - GAB
 };
 
 } // namespace
diff --git a/selfdrive/car/hyundai/interface.py b/selfdrive/car/hyundai/interface.py
index 66bf303de..62be75201 100644
--- a/selfdrive/car/hyundai/interface.py
+++ b/selfdrive/car/hyundai/interface.py
@@ -9,6 +9,10 @@ from selfdrive.car import STD_CARGO_KG, create_button_event, scale_tire_stiffnes
 from selfdrive.car.interfaces import CarInterfaceBase
 from selfdrive.car.disable_ecu import disable_ecu
 
+# PFEIFER - GAB {{
+from selfdrive.controls.gap_adjust_button import gap_adjust_button
+# }} PFEIFER - GAB
+
 Ecu = car.CarParams.Ecu
 ButtonType = car.CarState.ButtonEvent.Type
 EventName = car.CarEvent.EventName
@@ -328,6 +332,11 @@ class CarInterface(CarInterfaceBase):
 
       ret.buttonEvents = buttonEvents
 
+    # PFEIFER - GAB {{
+    gap_button_pressed = (self.CS.cruise_buttons[-1] == Buttons.GAP_DIST)
+    gap_adjust_button.update(gap_button_pressed)
+    # }} PFEIFER - GAB
+
     # On some newer model years, the CANCEL button acts as a pause/resume button based on the PCM state
     # To avoid re-engaging when openpilot cancels, check user engagement intention via buttons
     # Main button also can trigger an engagement on these cars
diff --git a/selfdrive/controls/gap_adjust_button.py b/selfdrive/controls/gap_adjust_button.py
new file mode 100644
index 000000000..35d5d0c76
--- /dev/null
+++ b/selfdrive/controls/gap_adjust_button.py
@@ -0,0 +1,8 @@
+# PFEIFER - GAB
+
+from selfdrive.controls.button_manager import Button, ButtonState
+
+# export button state so only one import is necessary
+GapButtonState = ButtonState
+
+gap_adjust_button = Button("GapAdjustButton")
-- 
2.41.0


From 6e1276729587c9f968fe297c94e7e6a7e20970c3 Mon Sep 17 00:00:00 2001
From: Jacob Pfeifer <jacob@pfeifer.dev>
Date: Sat, 10 Jun 2023 15:35:40 -0400
Subject: [PATCH 3/3] gap adjust control

---
 selfdrive/car/hyundai/hyundaican.py      | 14 ++++++-
 selfdrive/controls/controlsd.py          |  8 ++++
 selfdrive/controls/gap_adjust_control.py | 47 ++++++++++++++++++++++++
 3 files changed, 67 insertions(+), 2 deletions(-)
 create mode 100644 selfdrive/controls/gap_adjust_control.py

diff --git a/selfdrive/car/hyundai/hyundaican.py b/selfdrive/car/hyundai/hyundaican.py
index dc5a5b628..97b75fa93 100644
--- a/selfdrive/car/hyundai/hyundaican.py
+++ b/selfdrive/car/hyundai/hyundaican.py
@@ -1,5 +1,7 @@
 import crcmod
 from selfdrive.car.hyundai.values import CAR, CHECKSUM, CAMERA_SCC_CAR
+# PFEIFER - GAC {{
+from selfdrive.controls.gap_adjust_control import gap_adjust
 
 hyundai_checksum = crcmod.mkCrcFun(0x11D, initCrc=0xFD, rev=False, xorOut=0xdf)
 
@@ -128,9 +130,14 @@ def create_lfahda_mfc(packer, enabled, hda_set_speed=0):
 def create_acc_commands(packer, enabled, accel, upper_jerk, idx, lead_visible, set_speed, stopping, long_override):
   commands = []
 
+  # PFEIFER - GAC {{
+  gap_set = gap_adjust.state + 1
+  # }} PFEIFER - GAC
+
   scc11_values = {
     "MainMode_ACC": 1,
-    "TauGapSet": 4,
+    # "TauGapSet": 4,
+    "TauGapSet": gap_set,
     "VSetDis": set_speed if enabled else 0,
     "AliveCounterACC": idx % 0x10,
     "ObjValid": 1, # close lead makes controls tighter
@@ -181,7 +188,10 @@ def create_acc_opt(packer):
   commands = []
 
   scc13_values = {
-    "SCCDrvModeRValue": 2,
+    # "SCCDrvModeRValue": 2,
+    # PFEIFER - GAC {{
+    "SCCDrvModeRValue": 3 - gap_adjust.state,
+    # }} PFEIFER - GAC
     "SCC_Equip": 1,
     "Lead_Veh_Dep_Alert_USM": 2,
   }
diff --git a/selfdrive/controls/controlsd.py b/selfdrive/controls/controlsd.py
index 601d34e94..24ee20753 100755
--- a/selfdrive/controls/controlsd.py
+++ b/selfdrive/controls/controlsd.py
@@ -28,6 +28,10 @@ from selfdrive.controls.lib.alertmanager import AlertManager, set_offroad_alert
 from selfdrive.controls.lib.vehicle_model import VehicleModel
 from system.hardware import HARDWARE
 
+# PFEIFER - GAC {{
+from selfdrive.controls.gap_adjust_control import gap_adjust
+# }} PFEIFER - GAC
+
 SOFT_DISABLE_TIME = 3  # seconds
 LDW_MIN_SPEED = 31 * CV.MPH_TO_MS
 LANE_DEPARTURE_THRESHOLD = 0.1
@@ -855,6 +859,10 @@ class Controls:
     self.update_events(CS)
     cloudlog.timestamp("Events updated")
 
+    # PFEIFER - GAC {{
+    gap_adjust.update()
+    # }} PFEIFER - GAC
+
     if not self.read_only and self.initialized:
       # Update control state
       self.state_transition(CS)
diff --git a/selfdrive/controls/gap_adjust_control.py b/selfdrive/controls/gap_adjust_control.py
new file mode 100644
index 000000000..6e3fd9c0f
--- /dev/null
+++ b/selfdrive/controls/gap_adjust_control.py
@@ -0,0 +1,47 @@
+# PFEIFER - GAC
+
+from common.params import Params, put_nonblocking
+from enum import IntEnum
+from selfdrive.controls.gap_adjust_button import gap_adjust_button, GapButtonState
+
+params = Params()
+
+class GapAdjustState(IntEnum):
+  AGGRESSIVE = 0
+  STANDARD = 1
+  RELAXED = 2
+
+class GapAdjust:
+  state: GapAdjustState = GapAdjustState.STANDARD
+  button_transition_id = 0
+
+  def __init__(self) -> None:
+    self.load_state()
+
+  def load_state(self) -> None:
+    try:
+      self.state = GapAdjustState(int(params.get('LongitudinalPersonality')))
+    except:
+      self.state = GapAdjustState.STANDARD
+
+  def write_state(self) -> None:
+    put_nonblocking('LongitudinalPersonality', str(int(self.state)))
+
+  def update(self, load_state=True, write_state=True, load_button_state=True) -> None:
+    if load_button_state:
+      gap_adjust_button.load_state()
+
+    transition_id = gap_adjust_button.simple_transition_id;
+
+    if self.button_transition_id != transition_id:
+      self.button_transition_id = transition_id
+      if gap_adjust_button.simple_state == GapButtonState.SINGLE_PRESS:
+        if load_state:
+          self.load_state()
+
+        self.state = GapAdjustState((int(self.state) + 1) % 3)
+
+        if write_state:
+          self.write_state()
+
+gap_adjust = GapAdjust()
-- 
2.41.0

