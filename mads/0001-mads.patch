From c0882a15b3ce94b199bd5a20363163ccf5dedd66 Mon Sep 17 00:00:00 2001
From: Jacob Pfeifer <jacob@pfeifer.dev>
Date: Mon, 27 Mar 2023 21:31:37 -0400
Subject: [PATCH] mads

---
 common/params.cc                    |  6 +++
 panda                               |  2 +-
 selfdrive/car/hyundai/carstate.py   | 11 ++++
 selfdrive/car/interfaces.py         |  4 ++
 selfdrive/controls/controlsd.py     | 14 ++++-
 selfdrive/controls/mads.py          | 80 +++++++++++++++++++++++++++++
 selfdrive/ui/qt/offroad/settings.cc | 20 ++++++++
 7 files changed, 135 insertions(+), 2 deletions(-)
 create mode 100644 selfdrive/controls/mads.py

diff --git a/common/params.cc b/common/params.cc
index 428830a11..dbac0ef3b 100644
--- a/common/params.cc
+++ b/common/params.cc
@@ -202,6 +202,12 @@ std::unordered_map<std::string, uint32_t> keys = {
     {"Offroad_TemperatureTooHigh", CLEAR_ON_MANAGER_START},
     {"Offroad_UnofficialHardware", CLEAR_ON_MANAGER_START},
     {"Offroad_UpdateFailed", CLEAR_ON_MANAGER_START},
+
+// PFEIFER - mads {{
+    {"MadsEnabled", PERSISTENT},
+    {"DisengageLatOnBrake", PERSISTENT},
+    {"DisengageLatOnBlinker", PERSISTENT},
+// }} PFEIFER - mads
 };
 
 } // namespace
diff --git a/panda b/panda
index d70fa4e12..668cb7c4c 160000
--- a/panda
+++ b/panda
@@ -1 +1 @@
-Subproject commit d70fa4e1200ad47c66587c78fd90030a3be1cc43
+Subproject commit 668cb7c4cb651725f3eeee967587f0c66c83c51d
diff --git a/selfdrive/car/hyundai/carstate.py b/selfdrive/car/hyundai/carstate.py
index 22934c05b..d54d27019 100644
--- a/selfdrive/car/hyundai/carstate.py
+++ b/selfdrive/car/hyundai/carstate.py
@@ -19,6 +19,10 @@ class CarState(CarStateBase):
     super().__init__(CP)
     can_define = CANDefine(DBC[CP.carFingerprint]["pt"])
 
+    # PFEIFER - mads {{
+    self.mainEnabled = False
+    # }}
+
     self.cruise_buttons = deque([Buttons.NONE] * PREV_BUTTON_SAMPLES, maxlen=PREV_BUTTON_SAMPLES)
     self.main_buttons = deque([Buttons.NONE] * PREV_BUTTON_SAMPLES, maxlen=PREV_BUTTON_SAMPLES)
 
@@ -152,7 +156,14 @@ class CarState(CarStateBase):
     self.steer_state = cp.vl["MDPS12"]["CF_Mdps_ToiActive"]  # 0 NOT ACTIVE, 1 ACTIVE
     self.prev_cruise_buttons = self.cruise_buttons[-1]
     self.cruise_buttons.extend(cp.vl_all["CLU11"]["CF_Clu_CruiseSwState"])
+    # PFEIFER - mads {{
+    self.prev_main_buttons = self.main_buttons[-1]
+    # }} PFEIFER - mads
     self.main_buttons.extend(cp.vl_all["CLU11"]["CF_Clu_CruiseSwMain"])
+    # PFEIFER - mads {{
+    if self.prev_main_buttons == 0 and self.main_buttons[-1] != 0:
+        self.lateral_allowed = not self.lateral_allowed
+    # }} PFEIFER - mads
 
     return ret
 
diff --git a/selfdrive/car/interfaces.py b/selfdrive/car/interfaces.py
index 249818369..4630ff7c9 100644
--- a/selfdrive/car/interfaces.py
+++ b/selfdrive/car/interfaces.py
@@ -325,6 +325,10 @@ class CarStateBase(ABC):
     self.car_fingerprint = CP.carFingerprint
     self.out = car.CarState.new_message()
 
+    # PFEIFER - mads {{
+    self.lateral_allowed = False
+    # }} PFEIFER - mads
+
     self.cruise_buttons = 0
     self.left_blinker_cnt = 0
     self.right_blinker_cnt = 0
diff --git a/selfdrive/controls/controlsd.py b/selfdrive/controls/controlsd.py
index 1391d6570..abcc895e3 100755
--- a/selfdrive/controls/controlsd.py
+++ b/selfdrive/controls/controlsd.py
@@ -30,6 +30,10 @@ from selfdrive.locationd.calibrationd import Calibration
 from system.hardware import HARDWARE
 from selfdrive.manager.process_config import managed_processes
 
+# PFEIFER - mads {{
+from selfdrive.controls.mads import Mads
+# }} PFEIFER - mads
+
 SOFT_DISABLE_TIME = 3  # seconds
 LDW_MIN_SPEED = 31 * CV.MPH_TO_MS
 LANE_DEPARTURE_THRESHOLD = 0.1
@@ -111,7 +115,10 @@ class Controls:
     self.CP.alternativeExperience = 0
     if not self.disengage_on_accelerator:
       self.CP.alternativeExperience |= ALTERNATIVE_EXPERIENCE.DISABLE_DISENGAGE_ON_GAS
-
+    # PFEIFER - mads {{
+    self.mads = Mads(self.CI)
+    self.CP.alternativeExperience |= self.mads.alternative_experience
+    # }} PFEIFER - mads
     # read params
     self.is_metric = self.params.get_bool("IsMetric")
     self.is_ldw_enabled = self.params.get_bool("IsLdwEnabled")
@@ -207,6 +214,7 @@ class Controls:
     self.rk = Ratekeeper(100, print_delay_threshold=None)
     self.prof = Profiler(False)  # off by default
 
+
   def set_initial_state(self):
     if REPLAY:
       controls_state = Params().get("ReplayControlsState")
@@ -576,6 +584,10 @@ class Controls:
     standstill = CS.vEgo <= max(self.CP.minSteerSpeed, MIN_LATERAL_CONTROL_SPEED) or CS.standstill
     CC.latActive = self.active and not CS.steerFaultTemporary and not CS.steerFaultPermanent and \
                    (not standstill or self.joystick_mode)
+    # PFEIFER - mads {{
+    self.mads.update(CS, self.state, self.CP, self.sm['pandaStates'])
+    CC.latActive = self.mads.lat_active
+    # }} PFEIFER - mads
     CC.longActive = self.enabled and not self.events.any(ET.OVERRIDE_LONGITUDINAL) and self.CP.openpilotLongitudinalControl
 
     actuators = CC.actuators
diff --git a/selfdrive/controls/mads.py b/selfdrive/controls/mads.py
new file mode 100644
index 000000000..609f21e35
--- /dev/null
+++ b/selfdrive/controls/mads.py
@@ -0,0 +1,80 @@
+# PFEIFER - mads
+
+from cereal import log, car
+from common.params import Params
+from selfdrive.controls.lib.latcontrol import MIN_LATERAL_CONTROL_SPEED
+from panda import ALTERNATIVE_EXPERIENCE
+
+State = log.ControlsState.OpenpilotState
+ACTIVE_STATES = (State.enabled, State.softDisabling, State.overriding)
+
+class Mads:
+  def __init__(self, CI, braking = False, blinkers_active = False, op_active = False, standstill = False, steer_fault = False, invalid_gear = False):
+    self.CI = CI
+    self.braking = braking
+    self.blinkers_active = blinkers_active
+    self.op_active = op_active
+    self.standstill = standstill
+    self.steer_fault = steer_fault
+    self.invalid_gear = invalid_gear
+
+    self.CI.CS.lateral_allowed = False
+
+
+    self.params = Params()
+
+  def update(self, car_state, op_state, car_params, panda_states):
+    self.braking = car_state.brakePressed or car_state.regenBraking
+    self.blinkers_active = car_state.leftBlinker or car_state.rightBlinker
+    self.standstill = car_state.vEgo <= max(car_params.minSteerSpeed, MIN_LATERAL_CONTROL_SPEED) or car_state.standstill
+    self.op_active = op_state in ACTIVE_STATES
+    self.steer_fault = car_state.steerFaultTemporary or car_state.steerFaultPermanent
+    self.car_lat_active = car_state.cruiseState.available
+    self.invalid_gear = car_state.gearShifter not in [car.CarState.GearShifter.drive, car.CarState.GearShifter.neutral, car.CarState.GearShifter.sport, car.CarState.GearShifter.low, car.CarState.GearShifter.eco, car.CarState.GearShifter.manumatic]
+
+    # Always allow lateral when controls are allowed
+    if any(ps.controlsAllowed for ps in panda_states):
+      self.CI.CS.lateral_allowed = True
+
+  @property
+  def lat_active(self):
+
+
+    # If car is in a gear that does not move forward do not engage lateral
+    if self.invalid_gear:
+      return False
+
+    # If there is a steer fault lat is not available
+    if self.steer_fault:
+      return False
+
+    # If the car lateral control is not active lat cannot be active
+    if self.params.get_bool('MadsEnabled') and not self.CI.CS.lateral_allowed:
+      return False
+
+    # If mads is disabled then lat is only active when openpilot is active
+    if not self.params.get_bool('MadsEnabled') and not self.op_active:
+      return False
+
+    # If DisengageLatOnBrake is enabled we disable lat when braking
+    if self.params.get_bool('DisengageLatOnBrake') and self.braking:
+      return False
+
+    # If DisengageLatOnBlinker is enabled we disable lat when blinkers are on
+    if self.params.get_bool('DisengageLatOnBlinker') and self.blinkers_active:
+      return False
+
+    # Lat is enabled if we pass all previous tests for disengagement
+    return True
+
+  @property
+  def alternative_experience(self):
+    mads_enabled = self.params.get_bool('MadsEnabled')
+    dlob = self.params.get_bool('DisengageLatOnBrake')
+
+    if mads_enabled and dlob:
+      return ALTERNATIVE_EXPERIENCE.ENABLE_MADS
+    if mads_enabled and not dlob:
+      return ALTERNATIVE_EXPERIENCE.MADS_DISABLE_DISENGAGE_LATERAL_ON_BRAKE
+    return 0
+
diff --git a/selfdrive/ui/qt/offroad/settings.cc b/selfdrive/ui/qt/offroad/settings.cc
index 63b87149d..0e5a6d5b6 100644
--- a/selfdrive/ui/qt/offroad/settings.cc
+++ b/selfdrive/ui/qt/offroad/settings.cc
@@ -73,6 +73,26 @@ TogglesPanel::TogglesPanel(SettingsWindow *parent) : ListWidget(parent) {
       tr("When enabled, pressing the accelerator pedal will disengage openpilot."),
       "../assets/offroad/icon_disengage_on_accelerator.svg",
     },
+    // PFEIFER - mads {{
+    {
+      "MadsEnabled",
+      tr("Always on Lateral"),
+      tr("When enabled lateral control will be engaged even when longitudinal is not. Main cruise button toggles lateral control on and off."),
+      "../assets/img_experimental_white.svg",
+    },
+    {
+      "DisengageLatOnBrake",
+      tr("Disengage Lateral on Brake Pedal"),
+      tr("Disables lateral while the brake is being applied. Only changes behavior of Always on Lateral."),
+      "../assets/img_experimental_white.svg",
+    },
+    {
+      "DisengageLatOnBlinker",
+      tr("Disengage Lateral on Blinker"),
+      tr("Disables lateral while a blinker is being activated. Only changes behavior of Always on Lateral."),
+      "../assets/img_experimental_white.svg",
+    },
+    // }} PFEIFER - mads
 #ifdef ENABLE_MAPS
     {
       "NavSettingTime24h",
-- 
2.40.0

