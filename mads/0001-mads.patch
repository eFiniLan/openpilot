From cea2ecfc999ddf828e4834fb47327a15600c630e Mon Sep 17 00:00:00 2001
From: Jacob Pfeifer <jacob@pfeifer.dev>
Date: Sat, 10 Jun 2023 17:24:39 -0400
Subject: [PATCH] mads

---
 common/params.cc                    |   7 ++
 panda                               |   2 +-
 selfdrive/car/hyundai/carstate.py   |  11 +++
 selfdrive/car/interfaces.py         |   4 +
 selfdrive/controls/controlsd.py     |  18 +++-
 selfdrive/controls/mads.py          | 136 ++++++++++++++++++++++++++++
 selfdrive/ui/qt/offroad/settings.cc |  20 ++++
 selfdrive/ui/qt/onroad.cc           |   7 ++
 selfdrive/ui/qt/onroad.h            |   3 +
 selfdrive/ui/ui.h                   |   6 ++
 10 files changed, 212 insertions(+), 2 deletions(-)
 create mode 100644 selfdrive/controls/mads.py

diff --git a/common/params.cc b/common/params.cc
index be285c6aa..87ecbb7ac 100644
--- a/common/params.cc
+++ b/common/params.cc
@@ -203,6 +203,13 @@ std::unordered_map<std::string, uint32_t> keys = {
     {"Offroad_UnofficialHardware", CLEAR_ON_MANAGER_START},
     {"Offroad_UpdateFailed", CLEAR_ON_MANAGER_START},
     {"Offroad_Recalibration", CLEAR_ON_MANAGER_START | CLEAR_ON_ONROAD_TRANSITION},
+
+// PFEIFER - mads {{
+    {"MadsEnabled", PERSISTENT},
+    {"LateralAllowed", CLEAR_ON_MANAGER_START},
+    {"DisengageLatOnBrake", PERSISTENT},
+    {"DisengageLatOnBlinker", PERSISTENT},
+// }} PFEIFER - mads
 };
 
 } // namespace
diff --git a/panda b/panda
index b56340590..4dba9f7c8 160000
--- a/panda
+++ b/panda
@@ -1 +1 @@
-Subproject commit b56340590485bba2428538259e020f176127458c
+Subproject commit 4dba9f7c80a4111e24d28cb44b47a05a26a15c8f
diff --git a/selfdrive/car/hyundai/carstate.py b/selfdrive/car/hyundai/carstate.py
index 9bf2e0d4c..c4e650696 100644
--- a/selfdrive/car/hyundai/carstate.py
+++ b/selfdrive/car/hyundai/carstate.py
@@ -10,6 +10,10 @@ from selfdrive.car.hyundai.hyundaicanfd import CanBus
 from selfdrive.car.hyundai.values import HyundaiFlags, CAR, DBC, CAN_GEARS, CAMERA_SCC_CAR, CANFD_CAR, EV_CAR, HYBRID_CAR, Buttons, CarControllerParams
 from selfdrive.car.interfaces import CarStateBase
 
+# PFEIFER - mads {{
+from selfdrive.controls.mads import Mads
+# }} PFEIFER - mads
+
 PREV_BUTTON_SAMPLES = 8
 CLUSTER_SAMPLE_RATE = 20  # frames
 
@@ -152,7 +156,14 @@ class CarState(CarStateBase):
     self.steer_state = cp.vl["MDPS12"]["CF_Mdps_ToiActive"]  # 0 NOT ACTIVE, 1 ACTIVE
     self.prev_cruise_buttons = self.cruise_buttons[-1]
     self.cruise_buttons.extend(cp.vl_all["CLU11"]["CF_Clu_CruiseSwState"])
+    # PFEIFER - mads {{
+    self.prev_main_buttons = self.main_buttons[-1]
+    # }} PFEIFER - mads
     self.main_buttons.extend(cp.vl_all["CLU11"]["CF_Clu_CruiseSwMain"])
+    # PFEIFER - mads {{
+    if self.prev_main_buttons == 0 and self.main_buttons[-1] != 0:
+      Mads.toggle_lateral_allowed()
+    # }} PFEIFER - mads
 
     return ret
 
diff --git a/selfdrive/car/interfaces.py b/selfdrive/car/interfaces.py
index e5d743087..517f0d515 100644
--- a/selfdrive/car/interfaces.py
+++ b/selfdrive/car/interfaces.py
@@ -328,6 +328,10 @@ class CarStateBase(ABC):
     self.car_fingerprint = CP.carFingerprint
     self.out = car.CarState.new_message()
 
+    # PFEIFER - mads {{
+    self.lateral_allowed = False
+    # }} PFEIFER - mads
+
     self.cruise_buttons = 0
     self.left_blinker_cnt = 0
     self.right_blinker_cnt = 0
diff --git a/selfdrive/controls/controlsd.py b/selfdrive/controls/controlsd.py
index 82c66a20f..d31c29480 100755
--- a/selfdrive/controls/controlsd.py
+++ b/selfdrive/controls/controlsd.py
@@ -27,6 +27,10 @@ from selfdrive.controls.lib.alertmanager import AlertManager, set_offroad_alert
 from selfdrive.controls.lib.vehicle_model import VehicleModel
 from system.hardware import HARDWARE
 
+# PFEIFER - mads {{
+from selfdrive.controls.mads import Mads
+# }} PFEIFER - mads
+
 SOFT_DISABLE_TIME = 3  # seconds
 LDW_MIN_SPEED = 31 * CV.MPH_TO_MS
 LANE_DEPARTURE_THRESHOLD = 0.1
@@ -107,7 +111,10 @@ class Controls:
     self.CP.alternativeExperience = 0
     if not self.disengage_on_accelerator:
       self.CP.alternativeExperience |= ALTERNATIVE_EXPERIENCE.DISABLE_DISENGAGE_ON_GAS
-
+    # PFEIFER - mads {{
+    self.mads = Mads(self.CI)
+    self.CP.alternativeExperience |= self.mads.alternative_experience
+    # }} PFEIFER - mads
     # read params
     self.is_metric = self.params.get_bool("IsMetric")
     self.is_ldw_enabled = self.params.get_bool("IsLdwEnabled")
@@ -554,6 +561,11 @@ class Controls:
     self.active = self.state in ACTIVE_STATES
     if self.active:
       self.current_alert_types.append(ET.WARNING)
+    # PFEIFER - MADS {{
+    # Ensure we send warnings when only lat is active
+    elif self.mads.lat_active:
+      self.current_alert_types.append(ET.WARNING)
+    # }}
 
   def state_control(self, CS):
     """Given the state, this function returns a CarControl packet"""
@@ -580,6 +592,10 @@ class Controls:
     standstill = CS.vEgo <= max(self.CP.minSteerSpeed, MIN_LATERAL_CONTROL_SPEED) or CS.standstill
     CC.latActive = self.active and not CS.steerFaultTemporary and not CS.steerFaultPermanent and \
                    (not standstill or self.joystick_mode)
+    # PFEIFER - mads {{
+    self.mads.update(CS, self.state, self.CP, self.sm, self.AM)
+    CC.latActive = self.mads.lat_active
+    # }} PFEIFER - mads
     CC.longActive = self.enabled and not self.events.any(ET.OVERRIDE_LONGITUDINAL) and self.CP.openpilotLongitudinalControl
 
     actuators = CC.actuators
diff --git a/selfdrive/controls/mads.py b/selfdrive/controls/mads.py
new file mode 100644
index 000000000..b2986d635
--- /dev/null
+++ b/selfdrive/controls/mads.py
@@ -0,0 +1,136 @@
+# PFEIFER - mads
+
+from cereal import log, car
+from common.params import Params, put_bool_nonblocking
+from selfdrive.controls.lib.latcontrol import MIN_LATERAL_CONTROL_SPEED
+from panda import ALTERNATIVE_EXPERIENCE
+from selfdrive.controls.lib.events import EngagementAlert, AudibleAlert
+
+State = log.ControlsState.OpenpilotState
+ACTIVE_STATES = (State.enabled, State.softDisabling, State.overriding)
+
+# Speeds below this will deactivate lateral controls
+STOP_SPEED = 0.5 # m/s
+
+mem_params = Params("/dev/shm/params")
+"""
+A speed optimization, Params with a base path in /dev/shm/params.
+
+/dev/shm is a memory mapped folder and does not persistently store across
+reboots. The advantage to using a memory mapped folder is that it should be
+very fast and consistent for both writes and reads.
+
+If using the real filesystem placing data can, in extreme circumstances,
+take over 1 second. put_bool_nonblocking helps with this by creating a
+thread but this can create race conditions. If we need to block but don't
+care about persistence across reboots the memory mapped location should
+avoid random lag.
+"""
+
+class Mads:
+  def __init__(self, CI, braking = False, blinkers_active = False, op_active = False, standstill = False, steer_fault = False, invalid_gear = False):
+    self.CI = CI
+    self.braking = braking
+    self.blinkers_active = blinkers_active
+    self.op_active = op_active
+    self.standstill = standstill
+    self.steer_fault = steer_fault
+    self.invalid_gear = invalid_gear
+    self.last_lat_allowed = False
+    self.stopped = True
+
+    self.params = Params()
+
+
+  @staticmethod
+  def get_lateral_allowed() -> bool:
+    return mem_params.get_bool("LateralAllowed");
+
+  @staticmethod
+  def set_lateral_allowed(lateral_allowed: bool) -> None:
+    mem_params.put_bool("LateralAllowed", lateral_allowed);
+    # also place lateral allowed in normal params for ui, but do not block
+    put_bool_nonblocking("LateralAllowed", lateral_allowed);
+
+  @staticmethod
+  def toggle_lateral_allowed() -> None:
+    lateral_allowed = Mads.get_lateral_allowed()
+    Mads.set_lateral_allowed(not lateral_allowed)
+
+  @property
+  def lateral_allowed(self) -> bool:
+    return Mads.get_lateral_allowed();
+
+  @lateral_allowed.setter
+  def lateral_allowed(self, lateral_allowed: bool) -> None:
+    Mads.set_lateral_allowed(lateral_allowed)
+
+  def update(self, car_state, op_state, car_params, sm, alert_manager):
+    panda_states = sm['pandaStates']
+    lateral_allowed = self.lateral_allowed
+    if self.last_lat_allowed != lateral_allowed:
+      alert = None
+      if lateral_allowed:
+        alert = EngagementAlert(AudibleAlert.engage)
+      else:
+        alert = EngagementAlert(AudibleAlert.disengage)
+      alert_manager.add_many(sm.frame, [alert])
+    self.last_lat_allowed = lateral_allowed
+    self.braking = car_state.brakePressed or car_state.regenBraking
+    self.blinkers_active = car_state.leftBlinker or car_state.rightBlinker
+    self.standstill = car_state.vEgo <= max(car_params.minSteerSpeed, MIN_LATERAL_CONTROL_SPEED) or car_state.standstill
+    self.op_active = op_state in ACTIVE_STATES
+    self.steer_fault = car_state.steerFaultTemporary or car_state.steerFaultPermanent
+    self.car_lat_active = car_state.cruiseState.available
+    self.invalid_gear = car_state.gearShifter not in [car.CarState.GearShifter.drive, car.CarState.GearShifter.sport, car.CarState.GearShifter.low, car.CarState.GearShifter.eco]
+    self.stopped = car_state.vEgo < STOP_SPEED
+
+    # Always allow lateral when controls are allowed
+    if any(ps.controlsAllowed for ps in panda_states) and not lateral_allowed:
+      self.lateral_allowed = True
+
+  @property
+  def lat_active(self):
+
+    # If car is in a gear that does not move forward do not engage lateral
+    if self.invalid_gear:
+      return False
+
+    # If there is a steer fault lat is not available
+    if self.steer_fault:
+      return False
+
+    # Disable lateral when vehicle is stopped to prevent "twitching" steering wheel
+    if self.stopped:
+      return False
+
+    # If the car lateral control is not active lat cannot be active
+    if self.params.get_bool('MadsEnabled') and not self.lateral_allowed:
+      return False
+
+    # If mads is disabled then lat is only active when openpilot is active
+    if not self.params.get_bool('MadsEnabled') and not self.op_active:
+      return False
+
+    # If DisengageLatOnBrake is enabled we disable lat when braking
+    if self.params.get_bool('DisengageLatOnBrake') and self.braking:
+      return False
+
+    # If DisengageLatOnBlinker is enabled we disable lat when blinkers are on
+    if self.params.get_bool('DisengageLatOnBlinker') and self.blinkers_active:
+      return False
+
+    # Lat is enabled if we pass all previous tests for disengagement
+    return True
+
+  @property
+  def alternative_experience(self):
+    mads_enabled = self.params.get_bool('MadsEnabled')
+    dlob = self.params.get_bool('DisengageLatOnBrake')
+    experience = 0
+    if mads_enabled:
+      experience |= ALTERNATIVE_EXPERIENCE.ENABLE_MADS
+    if not dlob:
+      experience |= ALTERNATIVE_EXPERIENCE.MADS_DISABLE_DISENGAGE_LATERAL_ON_BRAKE
+    return experience
+
diff --git a/selfdrive/ui/qt/offroad/settings.cc b/selfdrive/ui/qt/offroad/settings.cc
index e37e5a984..51ecbe977 100644
--- a/selfdrive/ui/qt/offroad/settings.cc
+++ b/selfdrive/ui/qt/offroad/settings.cc
@@ -73,6 +73,26 @@ TogglesPanel::TogglesPanel(SettingsWindow *parent) : ListWidget(parent) {
       tr("Display speed in km/h instead of mph."),
       "../assets/offroad/icon_metric.png",
     },
+    // PFEIFER - mads {{
+    {
+      "MadsEnabled",
+      tr("Always on Lateral"),
+      tr("When enabled lateral control will be engaged even when longitudinal is not. Main cruise button toggles lateral control on and off."),
+      "../assets/img_experimental_white.svg",
+    },
+    {
+      "DisengageLatOnBrake",
+      tr("Disengage Lateral on Brake Pedal"),
+      tr("Disables lateral while the brake is being applied. Only changes behavior of Always on Lateral."),
+      "../assets/img_experimental_white.svg",
+    },
+    {
+      "DisengageLatOnBlinker",
+      tr("Disengage Lateral on Blinker"),
+      tr("Disables lateral while a blinker is being activated. Only changes behavior of Always on Lateral."),
+      "../assets/img_experimental_white.svg",
+    },
+    // }} PFEIFER - mads
 #ifdef ENABLE_MAPS
     {
       "NavSettingTime24h",
diff --git a/selfdrive/ui/qt/onroad.cc b/selfdrive/ui/qt/onroad.cc
index af07f179c..a66d94713 100644
--- a/selfdrive/ui/qt/onroad.cc
+++ b/selfdrive/ui/qt/onroad.cc
@@ -52,6 +52,13 @@ OnroadWindow::OnroadWindow(QWidget *parent) : QWidget(parent) {
 
 void OnroadWindow::updateState(const UIState &s) {
   QColor bgColor = bg_colors[s.status];
+  // PFEIFER - mads {{
+  params = Params();
+  if(s.status == STATUS_DISENGAGED && params.getBool("LateralAllowed")){
+      bgColor = bg_colors[STATUS_LAT_ALLOWED];
+  }
+  // }} PFEIFER - mads
+
   Alert alert = Alert::get(*(s.sm), s.scene.started_frame);
   if (s.sm->updated("controlsState") || !alert.equal({})) {
     if (alert.type == "controlsUnresponsive") {
diff --git a/selfdrive/ui/qt/onroad.h b/selfdrive/ui/qt/onroad.h
index 73c2a3789..e7c02f535 100644
--- a/selfdrive/ui/qt/onroad.h
+++ b/selfdrive/ui/qt/onroad.h
@@ -123,6 +123,9 @@ private:
   QColor bg = bg_colors[STATUS_DISENGAGED];
   QWidget *map = nullptr;
   QHBoxLayout* split;
+  // PFEIFER - mads {{
+  Params params;
+  // }} PFEIFER - mads
 
 private slots:
   void offroadTransition(bool offroad);
diff --git a/selfdrive/ui/ui.h b/selfdrive/ui/ui.h
index 2df047003..ad2195e6e 100644
--- a/selfdrive/ui/ui.h
+++ b/selfdrive/ui/ui.h
@@ -85,6 +85,9 @@ typedef enum UIStatus {
   STATUS_ENGAGED,
   STATUS_WARNING,
   STATUS_ALERT,
+  // PFEIFER - mads {{
+  STATUS_LAT_ALLOWED,
+  // }} PFEIFER - mads
 } UIStatus;
 
 const QColor bg_colors [] = {
@@ -93,6 +96,9 @@ const QColor bg_colors [] = {
   [STATUS_ENGAGED] = QColor(0x17, 0x86, 0x44, 0xf1),
   [STATUS_WARNING] = QColor(0xDA, 0x6F, 0x25, 0xf1),
   [STATUS_ALERT] = QColor(0xC9, 0x22, 0x31, 0xf1),
+  // PFEIFER - mads {{
+  [STATUS_LAT_ALLOWED] = QColor(0x6f, 0xc0, 0xc9, 0xf1),
+  // }} PFEIFER - mads
 };
 
 typedef struct UIScene {
-- 
2.41.0

